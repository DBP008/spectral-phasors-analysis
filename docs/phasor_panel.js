importScripts("https://cdn.jsdelivr.net/pyodide/v0.28.2/full/pyodide.js");

function sendPatch(patch, buffers, msg_id) {
  self.postMessage({
    type: 'patch',
    patch: patch,
    buffers: buffers
  })
}

async function startApplication() {
  console.log("Loading pyodide...");
  self.postMessage({type: 'status', msg: 'Loading pyodide'})
  self.pyodide = await loadPyodide();
  self.pyodide.globals.set("sendPatch", sendPatch);
  console.log("Loaded pyodide!");
  const data_archives = [];
  for (const archive of data_archives) {
    let zipResponse = await fetch(archive);
    let zipBinary = await zipResponse.arrayBuffer();
    self.postMessage({type: 'status', msg: `Unpacking ${archive}`})
    self.pyodide.unpackArchive(zipBinary, "zip");
  }
  await self.pyodide.loadPackage("micropip");
  self.postMessage({type: 'status', msg: `Installing environment`})
  try {
    await self.pyodide.runPythonAsync(`
      import micropip
      await micropip.install(['https://cdn.holoviz.org/panel/wheels/bokeh-3.8.2-py3-none-any.whl', 'https://cdn.holoviz.org/panel/1.8.7/dist/wheels/panel-1.8.7-py3-none-any.whl', 'pyodide-http', 'colorcet', 'holoviews', 'hvplot', 'matplotlib', 'numpy', 'pandas', 'scipy', 'tifffile', 'xarray']);
    `);
  } catch(e) {
    console.log(e)
    self.postMessage({
      type: 'status',
      msg: `Error while installing packages`
    });
  }
  console.log("Environment loaded!");
  self.postMessage({type: 'status', msg: 'Executing code'})
  try {
    const [docs_json, render_items, root_ids] = await self.pyodide.runPythonAsync(`\nimport asyncio\n\nfrom panel.io.pyodide import init_doc, write_doc\n\ninit_doc()\n\n# -*- coding: utf-8 -*-\n\nimport io\n\nimport panel as pn\nimport numpy as np\nfrom scipy.stats import norm\nimport pandas as pd\nimport xarray as xr\nimport holoviews as hv\nfrom holoviews import streams\nfrom itertools import cycle\nfrom matplotlib.path import Path as MplPath\nimport colorcet\nimport tifffile\nimport hvplot.xarray   # noqa: F401 \u2013 registers hvplot accessor\nimport hvplot.pandas   # noqa: F401 \u2013 registers hvplot accessor on DataFrames\nimport sys\n\npn.extension("bokeh", "mathjax", sizing_mode="stretch_width")\nhv.extension("bokeh")\n\n# \u2500\u2500 Core math helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n\ndef calculate_phasor_transform(ds: xr.Dataset) -> xr.Dataset:\n    fft_values = xr.apply_ufunc(\n        np.fft.fft,\n        ds.intensity,\n        input_core_dims=[["wavelength"]],\n        output_core_dims=[["harmonic_bin"]],\n    )\n    dc_component = fft_values.isel(harmonic_bin=0).real\n    h = int(ds.attrs.get("harmonic", 1))\n    harmonic_data = fft_values.isel(harmonic_bin=h)\n    ds["G"] = harmonic_data.real / dc_component\n    ds["S"] = harmonic_data.imag / dc_component\n    return ds\n\n\ndef add_spectral_reference(ds: xr.Dataset, n_ref_points: int = 1000) -> xr.Dataset:\n    harmonic = int(ds.attrs.get("harmonic", 1))\n    w_min = ds["wavelength"].min().item()\n    w_max = ds["wavelength"].max().item()\n    w_ref = np.linspace(w_min, w_max, n_ref_points)\n    indices = np.arange(n_ref_points)\n    phase = -2 * np.pi * harmonic * indices / n_ref_points\n    ds = ds.assign_coords(wavelength_ref=w_ref)\n    ds["G_ref"] = (("wavelength_ref",), np.cos(phase))\n    ds["S_ref"] = (("wavelength_ref",), np.sin(phase))\n    return ds\n\n\ndef make_gaussian(wavelengths: np.ndarray, mean: float, std: float) -> np.ndarray:\n    # return np.exp(-0.5 * ((wavelengths - mean) / std) ** 2)\n    # g = np.exp(-0.5 * ((wavelengths - mean) / std) ** 2)\n    # area = np.trapezoid(g, wavelengths)\n    # return g / area\n    return norm.pdf(wavelengths, loc=mean, scale=std)\n\n\ndef make_spectra_dataset(\n    wavelengths: np.ndarray,\n    intensities: np.ndarray,\n    harmonic_n: int,\n    sample_names: list[str] | None = None,\n) -> xr.Dataset:\n    """Build a clean xr.Dataset from a (samples \xd7 wavelength) array.\n\n    If *sample_names* is provided, a \`\`sample_name\`\` coordinate is attached\n    along the \`\`sample\`\` dimension.  The \`\`sample\`\` dimension itself stays\n    integer-valued so positional indexing keeps working everywhere.\n    """\n    n_samples = intensities.shape[0]\n    coords: dict = {\n        "sample": np.arange(n_samples),\n        "wavelength": wavelengths,\n    }\n    if sample_names is not None:\n        coords["sample_name"] = ("sample", list(sample_names))\n\n    ds = xr.Dataset(\n        data_vars={\n            "intensity": (["sample", "wavelength"], intensities),\n            "G": (["sample"], np.full(n_samples, np.nan)),\n            "S": (["sample"], np.full(n_samples, np.nan)),\n        },\n        coords=coords,\n        attrs={"harmonic": harmonic_n},\n    )\n    ds.wavelength.attrs = {"units": "nm"}\n    ds.G.attrs = {"long_name": "Phasor G (real)"}\n    ds.S.attrs = {"long_name": "Phasor S (imaginary)"}\n    return ds\n\n\ndef get_wavelengths(start: float, step: float, end: float) -> np.ndarray:\n    return np.arange(start, end + step / 2, step)\n\n\ndef parse_uploaded_csv(file_bytes: bytes) -> tuple[np.ndarray, np.ndarray, list[str]]:\n    """Parse an instrument-exported CSV into (wavelengths, intensities, names).\n\n    Expected layout\n    ---------------\n    Row 0 : sample names in columns 0, 2, 4, \u2026  (odd cols empty)\n    Row 1 : repeated "Wavelength (nm), Intensity (a.u.)" headers\n    Row 2+ : data pairs  (wavelength, intensity) \xd7 N_samples\n    A blank row marks the end of the spectral data.\n\n    Returns\n    -------\n    wavelengths : 1-D array  (N_wl,)\n    intensities : 2-D array  (N_samples, N_wl)\n    names       : list[str]  length N_samples\n    """\n    text = file_bytes.decode("utf-8", errors="replace")\n    lines = text.splitlines()\n\n    # \u2500\u2500 Row 0: sample names \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    header_cells = lines[0].split(",")\n    # Names sit at even indices (0, 2, 4, \u2026)\n    names = [header_cells[i].strip() for i in range(0, len(header_cells), 2) if header_cells[i].strip()]\n\n    # \u2500\u2500 Find the first blank row (signals end of data) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    data_end = len(lines)\n    for idx, line in enumerate(lines[2:], start=2):   # skip header rows\n        if line.strip() == "" or line.replace(",", "").strip() == "":\n            data_end = idx\n            break\n\n    # \u2500\u2500 Parse numeric block \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    # Use pandas for robust float parsing of the data block\n    csv_block = "\\n".join(lines[2:data_end])\n    df = pd.read_csv(io.StringIO(csv_block), header=None)\n\n    n_samples = len(names)\n    wavelengths = df.iloc[:, 0].to_numpy(dtype=float)\n    intensities = np.column_stack(\n        [df.iloc[:, 2 * i + 1].to_numpy(dtype=float) for i in range(n_samples)]\n    ).T  # shape (n_samples, n_wavelengths)\n\n    return wavelengths, intensities, names\n\n\n# \u2500\u2500 Plot helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n\ndef create_phasor_plot(ds: xr.Dataset):\n    df_samples = ds[["G", "S"]].to_dataframe().reset_index()\n    df_ref = ds[["G_ref", "S_ref"]].to_dataframe().reset_index()\n\n    ref_chart = df_ref.hvplot.points(\n        x="G_ref",\n        y="S_ref",\n        color="wavelength_ref",\n        cmap="spectral_r",\n        size=28,\n        colorbar=False,\n        tools=["hover"],\n    )\n\n    single_sample = len(df_samples) == 1\n    if single_sample:\n        color_mapping = {int(df_samples["sample"].iloc[0]): "steelblue"}\n        sample_chart = df_samples.hvplot.points(\n            x="G",\n            y="S",\n            color="steelblue",\n            size=50,\n            colorbar=False,\n            tools=["hover", "box_select", "lasso_select", "tap"],\n        )\n    else:\n        color_mapping = dict(\n            zip(df_samples["sample"].tolist(), cycle(colorcet.b_glasbey_hv))\n        )\n        sample_chart = df_samples.hvplot.points(\n            x="G",\n            y="S",\n            color="sample",\n            cmap=color_mapping,\n            size=45,\n            colorbar=False,\n            tools=["hover", "box_select", "lasso_select", "tap"],\n        )\n\n    phasor_plot = (ref_chart * sample_chart).opts(\n        hv.opts.Points(\n            frame_width=500,\n            frame_height=500,\n            padding=0.1,\n            xlabel="G",\n            ylabel="S",\n            show_grid=True,\n            show_legend=False,\n            title="Phasor Plot",\n        )\n    )\n    return phasor_plot, sample_chart, color_mapping\n\n\ndef build_spectrum_dmap(\n    ds: xr.Dataset,\n    sample_plot: hv.Points,\n    color_mapping: dict,\n    show_individual: bool = False,\n) -> hv.DynamicMap:\n    """Return a DynamicMap wired to *sample_plot*'s Selection1D stream.\n\n    When show_individual is True, individual spectra are rendered as a\n    pre-built hv.NdOverlay using the same *color_mapping* dict as the\n    phasor plot so dot and line colours correspond 1-to-1.\n    Selection filters the overlay with .select(sample=index).\n    """\n    selection = streams.Selection1D(source=sample_plot)\n\n    # \u2500\u2500 Compute axis limits once from the full dataset \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    wl_min = float(ds.wavelength.min())\n    wl_max = float(ds.wavelength.max())\n    int_min = float(ds.intensity.min())\n    int_max = float(ds.intensity.max())\n    wl_pad  = (wl_max  - wl_min)  * 0.02\n    int_pad = (int_max - int_min) * 0.05\n    xlim = (wl_min  - wl_pad,  wl_max  + wl_pad)\n    ylim = (int_min - int_pad, int_max + int_pad)\n\n    # Build the full individual-spectra overlay once (outside the callback)\n    # so filtering is cheap and colours are consistent.\n    hv_ds = hv.Dataset(\n        ds.intensity.to_dataframe().reset_index(),\n        kdims=["wavelength", "sample"],\n        vdims="intensity",\n    )\n    individual_plot = hv_ds.to(hv.Curve, "wavelength", "intensity").overlay("sample").opts(\n        hv.opts.Curve(\n            color=hv.Cycle(list(color_mapping.values())),\n            frame_width=800,\n            frame_height=500,\n            line_width=3,\n            tools=["hover"],\n            # hover_tooltips=[("sample","@sample"), ("wavelength","@x"), ("intensity","@y")],\n            xlabel="wavelength (nm)",\n            ylabel="intensity",\n            title="spectrum",\n            xlim=xlim,\n            ylim=ylim,\n            framewise=True\n        ),\n        hv.opts.NdOverlay(show_legend=False, framewise=True),\n    )\n\n    def select_spectrum(index):\n        if show_individual and len(index) <= 300:\n            if not index:\n                return individual_plot\n            return individual_plot.select(sample=index)\n\n        # \u2500\u2500 Average mode \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        if not index:\n            selected = ds.intensity\n            title = "All Samples"\n        else:\n            selected = ds.intensity.isel(sample=index)\n            title = f"{len(index)} Selected"\n\n        suffix = " [avg mode: >300]" if show_individual else ""\n        avg_curve = selected.mean("sample", keep_attrs=True).hvplot.line(\n            x="wavelength",\n            y="intensity",\n            title=f"Average Spectrum ({title}){suffix}",\n            color="black",\n            line_width=3,\n            frame_width=800,\n            frame_height=500,\n            xlim=xlim,\n            ylim=ylim,\n        ).opts(framewise=True)\n        return hv.NdOverlay({"Average": avg_curve}, kdims="sample").opts(\n            show_legend=False,\n            framewise=True,\n        )\n\n    return hv.DynamicMap(select_spectrum, streams=[selection]).opts(framewise=True)\n\n\n# \u2500\u2500 Global widgets \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nstart_lambda_input = pn.widgets.FloatInput(\n    name="Start \u03bb (nm)", value=400, step=10, width=160\n)\nstep_lambda_input = pn.widgets.FloatInput(\n    name="Step \u03bb (nm)", value=5, step=1, width=160\n)\nend_lambda_input = pn.widgets.FloatInput(\n    name="End \u03bb (nm)", value=700, step=10, width=160\n)\nharmonic_input = pn.widgets.IntInput(\n    name="Harmonic N", value=1, step=1, start=1, width=160\n)\nshow_individual = pn.widgets.Toggle(\n    name="Show Individual Spectra", button_type="default", value=False\n)\n\n# \u2500\u2500 Tab 1 widgets: single gaussian \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nt1_mean = pn.widgets.FloatSlider(\n    name="Mean (nm)", start=400, end=700, value=550, step=1\n)\nt1_std = pn.widgets.FloatSlider(\n    name="Std (nm)", start=1, end=150, value=20, step=1\n)\n\n# \u2500\u2500 Tab 3 widgets: CSV upload \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nt3_file_input = pn.widgets.FileInput(accept=".csv", multiple=False, name="Upload CSV")\n\n# \u2500\u2500 Tab 4 widgets: TIFF image upload \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nt4_file_input = pn.widgets.FileInput(accept=".tif,.tiff", multiple=False, name="Upload TIFF")\n\n# \u2500\u2500 Tab 2 widgets: multi gaussian + noise \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nt2_n_samples = pn.widgets.IntSlider(\n    name="N samples", start=10, end=500, value=100, step=10\n)\nt2_mean_base = pn.widgets.FloatSlider(\n    name="Center wavelength \u03bb (nm)", start=400, end=700, value=550, step=1\n)\nt2_mean_spread = pn.widgets.FloatSlider(\n    name="Wavelength variance \u03c3 (nm)", start=0, end=100, value=10, step=1\n)\nt2_std_base = pn.widgets.FloatSlider(\n    name="Wavelength jitter \u0394\u03bb (nm)", start=1, end=150, value=30, step=1\n)\nt2_std_spread = pn.widgets.FloatSlider(\n    name="Variance jitter \u0394\u03c3 (nm)", start=0, end=60, value=5, step=1\n)\nt2_add_noise = pn.widgets.Toggle(\n    name="Add Gaussian Noise", button_type="default", value=False\n)\nt2_snr = pn.widgets.FloatSlider(\n    name="SNR (dB)", start=0, end=40, value=20, step=1, disabled=True\n)\n\ndef _toggle_snr(event):\n    t2_snr.disabled = not event.new\n\nt2_add_noise.param.watch(_toggle_snr, "value")\n\n# \u2500\u2500 Tab 5 widgets: 2-way phasor deconvolution \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nt5_ref_a_wl = pn.widgets.FloatSlider(\n    name="Ref A \u03bb (nm)", start=400, end=700, value=480, step=1\n)\nt5_ref_a_std = pn.widgets.FloatSlider(\n    name="Ref A \u03c3 (nm)", start=1, end=150, value=20, step=1\n)\nt5_ref_b_wl = pn.widgets.FloatSlider(\n    name="Ref B \u03bb (nm)", start=400, end=700, value=620, step=1\n)\nt5_ref_b_std = pn.widgets.FloatSlider(\n    name="Ref B \u03c3 (nm)", start=1, end=150, value=35, step=1\n)\nt5_mix_ratio = pn.widgets.FloatSlider(\n    name="Intensity ratio (A fraction)", start=0.0, end=1.0, value=0.27, step=0.01\n)\nt5_n_samples = pn.widgets.IntSlider(\n    name="N samples", start=10, end=500, value=100, step=10\n)\nt5_add_noise = pn.widgets.Toggle(\n    name="Add Gaussian Noise", button_type="default", value=False\n)\nt5_snr = pn.widgets.FloatSlider(\n    name="SNR (dB)", start=0, end=40, value=4, step=1, disabled=True\n)\n\n\ndef _toggle_snr_t5(event):\n    t5_snr.disabled = not event.new\n\n\nt5_add_noise.param.watch(_toggle_snr_t5, "value")\n\n# \u2500\u2500 Tab 6 widgets: 3-way phasor deconvolution \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nt6_ref_a_wl = pn.widgets.FloatSlider(\n    name="Ref A \u03bb (nm)", start=400, end=700, value=420, step=1\n)\nt6_ref_a_std = pn.widgets.FloatSlider(\n    name="Ref A \u03c3 (nm)", start=1, end=150, value=20, step=1\n)\nt6_ref_b_wl = pn.widgets.FloatSlider(\n    name="Ref B \u03bb (nm)", start=400, end=700, value=488, step=1\n)\nt6_ref_b_std = pn.widgets.FloatSlider(\n    name="Ref B \u03c3 (nm)", start=1, end=150, value=45, step=1\n)\nt6_ref_c_wl = pn.widgets.FloatSlider(\n    name="Ref C \u03bb (nm)", start=400, end=700, value=640, step=1\n)\nt6_ref_c_std = pn.widgets.FloatSlider(\n    name="Ref C \u03c3 (nm)", start=1, end=150, value=30, step=1\n)\nt6_alpha = pn.widgets.FloatSlider(\n    name="\u03b1 (A fraction)", start=0.0, end=1.0, value=0.5, step=0.01\n)\nt6_beta = pn.widgets.FloatSlider(\n    name="\u03b2 (B fraction)", start=0.0, end=1.0, value=0.35, step=0.01\n)\nt6_gamma = pn.widgets.FloatSlider(\n    name="\u03b3 (C fraction)", start=0.0, end=1.0, value=0.15, step=0.01\n)\nt6_n_samples = pn.widgets.IntSlider(\n    name="N samples", start=10, end=500, value=100, step=10\n)\nt6_add_noise = pn.widgets.Toggle(\n    name="Add Gaussian Noise", button_type="default", value=False\n)\nt6_snr = pn.widgets.FloatSlider(\n    name="SNR (dB)", start=0, end=40, value=4, step=1, disabled=True\n)\n\n\ndef _toggle_snr_t6(event):\n    t6_snr.disabled = not event.new\n\n\nt6_add_noise.param.watch(_toggle_snr_t6, "value")\n\n# A simple lock to prevent the function from triggering itself\n_updating = False\n\ndef _clamp_abc(changed: str, event):\n    global _updating\n    if _updating: return\n    \n    _updating = True\n    try:\n        a, b, g = t6_alpha.value, t6_beta.value, t6_gamma.value\n        new_val = event.new\n        \n        if changed == "alpha":\n            remainder = 1.0 - new_val\n            old_sum = b + g\n            b = (remainder * b / old_sum) if old_sum > 0 else remainder / 2\n            g = remainder - b # Ensures exact sum to 1.0\n            t6_beta.value = round(b, 2)\n            t6_gamma.value = round(g, 2)\n            \n        elif changed == "beta":\n            remainder = 1.0 - new_val\n            old_sum = a + g\n            a = (remainder * a / old_sum) if old_sum > 0 else remainder / 2\n            g = remainder - a\n            t6_alpha.value = round(a, 2)\n            t6_gamma.value = round(g, 2)\n            \n        elif changed == "gamma":\n            remainder = 1.0 - new_val\n            old_sum = a + b\n            a = (remainder * a / old_sum) if old_sum > 0 else remainder / 2\n            b = remainder - a\n            t6_alpha.value = round(a, 2)\n            t6_beta.value = round(b, 2)\n    finally:\n        _updating = False\n\n# USE VALUE_THROTTLED TO DEBOUNCE\nt6_alpha.param.watch(lambda e: _clamp_abc("alpha", e), "value_throttled")\nt6_beta.param.watch(lambda e: _clamp_abc("beta", e), "value_throttled")\nt6_gamma.param.watch(lambda e: _clamp_abc("gamma", e), "value_throttled")\n\n\n# t6_alpha.param.watch(lambda e: _clamp_abc("alpha", e), "value")\n# t6_beta.param.watch(lambda e: _clamp_abc("beta", e), "value")\n# t6_gamma.param.watch(lambda e: _clamp_abc("gamma", e), "value")\n\n\n# \u2500\u2500 View callbacks \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n\ndef _validate_wavelengths(start, step, end):\n    if start >= end:\n        return pn.pane.Alert("Start \u03bb must be less than End \u03bb.", alert_type="danger")\n    if step <= 0:\n        return pn.pane.Alert("Step \u03bb must be positive.", alert_type="danger")\n    return None\n\n\n@pn.depends(\n    start_lambda_input,\n    step_lambda_input,\n    end_lambda_input,\n    harmonic_input,\n    t1_mean,\n    t1_std,\n    show_individual,\n)\ndef tab1_view(start, step, end, h, mean, std, show_ind):\n    err = _validate_wavelengths(start, step, end)\n    if err:\n        return err\n\n    wl = get_wavelengths(start, step, end)\n    # Single sample: shape (1, N_wl)\n    intensity = make_gaussian(wl, mean, std)[np.newaxis, :]\n    ds = make_spectra_dataset(wl, intensity, h)\n    ds = calculate_phasor_transform(ds)\n    ds = add_spectral_reference(ds)\n\n    phasor_plot, sample_plot, color_mapping = create_phasor_plot(ds)\n    dmap = build_spectrum_dmap(ds, sample_plot, color_mapping, show_individual=show_ind)\n    return pn.Row(phasor_plot, dmap, sizing_mode="stretch_width")\n\n\n@pn.depends(\n    start_lambda_input,\n    step_lambda_input,\n    end_lambda_input,\n    harmonic_input,\n    t2_n_samples,\n    t2_mean_base,\n    t2_mean_spread,\n    t2_std_base,\n    t2_std_spread,\n    t2_add_noise,\n    t2_snr,\n    show_individual,\n)\ndef tab2_view(\n    start, step, end, h,\n    n_samples, mean_base, mean_spread, std_base, std_spread,\n    add_noise, snr_db, show_ind,\n):\n    err = _validate_wavelengths(start, step, end)\n    if err:\n        return err\n\n    rng = np.random.default_rng()\n    wl = get_wavelengths(start, step, end)\n\n    # Draw random means and stds for each sample\n    means = (\n        rng.normal(mean_base, mean_spread, n_samples)\n        if mean_spread > 0\n        else np.full(n_samples, float(mean_base))\n    )\n    stds = (\n        np.clip(rng.normal(std_base, std_spread, n_samples), 0.5, None)\n        if std_spread > 0\n        else np.full(n_samples, float(std_base))\n    )\n\n    intensities = np.stack([make_gaussian(wl, m, s) for m, s in zip(means, stds)])\n\n    if add_noise:\n        snr_linear = 10 ** (snr_db / 10)\n        # Per-sample signal power \u2192 noise std\n        sig_power = np.mean(intensities ** 2, axis=1, keepdims=True)\n        noise_std = np.sqrt(sig_power / snr_linear)\n        noise = rng.standard_normal(intensities.shape) * noise_std\n        intensities = np.clip(intensities + noise, 0, None)\n\n    ds = make_spectra_dataset(wl, intensities, h)\n    ds = calculate_phasor_transform(ds)\n    ds = add_spectral_reference(ds)\n\n    phasor_plot, sample_plot, color_mapping = create_phasor_plot(ds)\n    dmap = build_spectrum_dmap(ds, sample_plot, color_mapping, show_individual=show_ind)\n    return pn.Row(phasor_plot, dmap, sizing_mode="stretch_width")\n\n\n@pn.depends(\n    t3_file_input,\n    harmonic_input,\n    show_individual,\n)\ndef tab3_view(file_bytes, h, show_ind):\n    if file_bytes is None:\n        return pn.pane.Alert(\n            "Upload a CSV file to begin.  "\n            "The wavelength range and spacing will be read from the file "\n            "(the global \u03bb parameters are **ignored** for this tab).",\n            alert_type="warning",\n        )\n\n    try:\n        wavelengths, intensities, sample_names = parse_uploaded_csv(file_bytes)\n    except Exception as exc:\n        return pn.pane.Alert(f"Error parsing CSV: {exc}", alert_type="danger")\n\n    wl_start, wl_end = wavelengths[0], wavelengths[-1]\n    wl_step = np.median(np.diff(wavelengths))\n    sample_lines = "\\n".join(\n        f"| {i} | {name} |" for i, name in enumerate(sample_names)\n    )\n    info_md = pn.pane.Markdown(\n        f"**CSV info** \u2014 {len(sample_names)} samples, \\n\\n"\n        f"\u03bb {wl_start:.1f}\u2013{wl_end:.1f} nm, "\n        f"step \u2248 {wl_step:.2f} nm\\n\\n"\n        f"| Index | Sample name |\\n"\n        f"|------:|-------------|\\n"\n        f"{sample_lines}"\n    )\n    warning = pn.pane.Alert(\n        "\u26a0\ufe0f Wavelength range and spacing are taken from the uploaded CSV.  "\n        "The global \u03bb start / step / end parameters do **not** apply to this tab.",\n        alert_type="warning",\n    )\n\n    ds = make_spectra_dataset(wavelengths, intensities, h, sample_names=sample_names)\n    ds = calculate_phasor_transform(ds)\n    ds = add_spectral_reference(ds)\n\n    phasor_plot, sample_plot, color_mapping = create_phasor_plot(ds)\n    dmap = build_spectrum_dmap(ds, sample_plot, color_mapping, show_individual=show_ind)\n    return pn.Column(\n        warning,\n        info_md,\n        pn.Row(phasor_plot, dmap, sizing_mode="stretch_width"),\n    )\n\n\n@pn.depends(\n    t4_file_input,\n    harmonic_input,\n    start_lambda_input,\n    end_lambda_input,\n)\ndef tab4_view(file_bytes, h, start, end):\n    combined_warning = pn.pane.Alert(\n        "\u26a0\ufe0f **Show Individual Spectra** is not available in TIFF image mode \u2014 "\n        "selections show averaged spectra only.  "\n        "**Step \u03bb** is ignored: wavelengths are computed as "\n        "linspace(Start \u03bb, End \u03bb, n_frames) using the number of TIFF frames.",\n        alert_type="warning",\n    )\n\n    if file_bytes is None:\n        return pn.Column(\n            combined_warning,\n            pn.pane.Alert(\n                "Upload a TIFF stack to begin.  "\n                "Set Start \u03bb and End \u03bb in the Global Parameters sidebar first.",\n                alert_type="secondary",\n            ),\n        )\n\n    if start >= end:\n        return pn.pane.Alert("Start \u03bb must be less than End \u03bb.", alert_type="danger")\n\n    try:\n        arr = tifffile.imread(io.BytesIO(file_bytes))\n    except Exception as exc:\n        return pn.pane.Alert(f"Error reading TIFF: {exc}", alert_type="danger")\n\n    # Normalise to (n_frames, H, W)\n    if arr.ndim == 2:\n        arr = arr[np.newaxis, :, :]\n    elif arr.ndim == 3:\n        pass  # already (n_frames, H, W) from tifffile\n    else:\n        return pn.pane.Alert(\n            f"Unexpected TIFF shape {arr.shape}. Expected a 3-D stack.",\n            alert_type="danger",\n        )\n\n    n_frames, H, W = arr.shape\n    wavelengths = np.linspace(start, end, n_frames)\n    wl_step_auto = (end - start) / max(n_frames - 1, 1)\n\n    info_md = pn.pane.Markdown(\n        f"**TIFF info** \u2014 {n_frames} frames, {H}\xd7{W} px  \\n"\n        f"\u03bb {start:.1f}\u2013{end:.1f} nm, auto step \u2248 {wl_step_auto:.2f} nm"\n    )\n\n    # \u2500\u2500 Build xarray Dataset \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    intensities_2d = arr.astype(float).transpose(1, 2, 0).reshape(H * W, n_frames)\n    x_coords = np.repeat(np.arange(H), W)\n    y_coords = np.tile(np.arange(W), H)\n    ds = xr.Dataset(\n        data_vars={\n            "intensity": (["sample", "wavelength"], intensities_2d),\n            "G": (["sample"], np.full(H * W, np.nan)),\n            "S": (["sample"], np.full(H * W, np.nan)),\n        },\n        coords={\n            "sample": np.arange(H * W),\n            "x": ("sample", x_coords),\n            "y": ("sample", y_coords),\n            "wavelength": wavelengths,\n        },\n        attrs={"harmonic": h},\n    )\n    ds.wavelength.attrs = {"units": "nm"}\n    ds = calculate_phasor_transform(ds)\n    ds = add_spectral_reference(ds)\n\n    # \u2500\u2500 Pre-extract arrays \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    _x      = ds["x"].values.astype(int)\n    _y      = ds["y"].values.astype(int)\n    _G      = ds["G"].values\n    _S      = ds["S"].values\n    _wl     = wavelengths\n    _Gref   = ds["G_ref"].values\n    _Sref   = ds["S_ref"].values\n    _wlref  = ds["wavelength_ref"].values\n    _intmat = ds["intensity"].values\n    _xdim   = np.arange(H)\n    _ydim   = np.arange(W)\n    _EMPTY  = (0.0, 0.0, 0.0, 0.0)\n    _IMG_WW = 420\n\n    ds_indexed = ds.set_index(sample=["x", "y"])\n    intensity_unstacked = ds_indexed["intensity"].unstack("sample")  # (wavelength, x, y)\n\n    # \u2500\u2500 Mask helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    def _imask_box(b):\n        if b is None or b == _EMPTY:\n            return np.zeros(len(_x), dtype=bool)\n        x0, y0, x1, y1 = b\n        return ((_x >= min(x0, x1)) & (_x <= max(x0, x1)) &\n                (_y >= min(y0, y1)) & (_y <= max(y0, y1)))\n\n    def _pmask_box(b):\n        if b is None or b == _EMPTY:\n            return np.zeros(len(_G), dtype=bool)\n        g0, s0, g1, s1 = b\n        return ((_G >= min(g0, g1)) & (_G <= max(g0, g1)) &\n                (_S >= min(s0, s1)) & (_S <= max(s0, s1)))\n\n    def _imask_lasso(geom):\n        if geom is None or len(geom) < 3:\n            return np.zeros(len(_x), dtype=bool)\n        return MplPath(geom).contains_points(np.column_stack([_x.astype(float), _y.astype(float)]))\n\n    def _pmask_lasso(geom):\n        if geom is None or len(geom) < 3:\n            return np.zeros(len(_G), dtype=bool)\n        return MplPath(geom).contains_points(np.column_stack([_G, _S]))\n\n    def _imask(bounds, geom):\n        return _imask_box(bounds) | _imask_lasso(geom)\n\n    def _pmask(bounds, geom):\n        return _pmask_box(bounds) | _pmask_lasso(geom)\n\n    # \u2500\u2500 Controls \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    wl_slider_t4 = pn.widgets.DiscreteSlider(\n        name="Wavelength (nm)",\n        options={f"{w:.1f} nm": i for i, w in enumerate(_wl)},\n        value=0,\n        width=_IMG_WW,\n    )\n    mode_toggle_t4 = pn.widgets.RadioButtonGroup(\n        name="Selection mode",\n        options=["Image", "Phasor"],\n        value="Image",\n        button_type="primary",\n    )\n    reset_btn_t4 = pn.widgets.Button(name="\u21ba  Reset", button_type="warning", width=100)\n\n    # \u2500\u2500 Streams \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    img_bounds_t4 = streams.BoundsXY(bounds=_EMPTY)\n    ph_bounds_t4  = streams.BoundsXY(bounds=_EMPTY)\n    img_lasso_t4  = streams.Lasso(geometry=None)\n    ph_lasso_t4   = streams.Lasso(geometry=None)\n\n    def _reset_all_t4():\n        img_bounds_t4.event(bounds=_EMPTY)\n        ph_bounds_t4.event(bounds=_EMPTY)\n        img_lasso_t4.event(geometry=None)\n        ph_lasso_t4.event(geometry=None)\n\n    mode_toggle_t4.param.watch(lambda e: _reset_all_t4(), "value")\n    reset_btn_t4.on_click(lambda e: _reset_all_t4())\n\n    # \u2500\u2500 Base image DynamicMap \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    def _base_image_t4(wl_idx, mode, ibounds, igeom):\n        data  = intensity_unstacked.isel(wavelength=wl_idx).values\n        has_img_sel = _imask(ibounds, igeom).any()\n        go_gray = (mode == "Phasor") or (mode == "Image" and has_img_sel)\n        cmap  = "gray"  if go_gray else "viridis"\n        alpha = 0.25    if go_gray else 1.0\n        return hv.Image(\n            (_xdim, _ydim, data.T),\n            kdims=["x", "y"], vdims=["intensity"],\n        ).opts(\n            cmap=cmap, colorbar=True, alpha=alpha,\n            frame_width=_IMG_WW, frame_height=_IMG_WW,\n            title=f"Image  \u2014  {_wl[wl_idx]:.1f} nm",\n            tools=["box_select", "lasso_select", "wheel_zoom"],\n            active_tools=["wheel_zoom"],\n        )\n\n    base_img_dmap_t4 = hv.DynamicMap(pn.bind(\n        _base_image_t4,\n        wl_idx=wl_slider_t4,\n        mode=mode_toggle_t4,\n        ibounds=img_bounds_t4.param.bounds,\n        igeom=img_lasso_t4.param.geometry,\n    ))\n    img_bounds_t4.source = base_img_dmap_t4\n    img_lasso_t4.source  = base_img_dmap_t4\n\n    # \u2500\u2500 Static phasor background \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    phasor_bg_t4 = hv.Points(pd.DataFrame({"G": _G, "S": _S}), kdims=["G", "S"]).opts(\n        color="lightgray", size=3, alpha=0.3,\n        frame_width=_IMG_WW, frame_height=_IMG_WW,\n        tools=["box_select", "lasso_select", "wheel_zoom"],\n        active_tools=["wheel_zoom"],\n        xlabel="G", ylabel="S", show_grid=True, padding=0.1,\n        title="Phasor",\n    )\n    ph_bounds_t4.source = phasor_bg_t4\n    ph_lasso_t4.source  = phasor_bg_t4\n\n    # \u2500\u2500 Reference arc \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    ref_arc_t4 = hv.Points(\n        pd.DataFrame({"G": _Gref, "S": _Sref, "wl": _wlref}),\n        kdims=["G", "S"], vdims=["wl"],\n    ).opts(color="wl", cmap="Spectral_r", size=6, alpha=0.6, colorbar=False, tools=["hover"])\n\n    # \u2500\u2500 Callbacks \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    def _make_phasor_overlay_t4(ibounds, igeom, pbounds, pgeom, mode):\n        if mode == "Image":\n            m, color = _imask(ibounds, igeom), "steelblue"\n        else:\n            m, color = _pmask(pbounds, pgeom), "tomato"\n        df = pd.DataFrame({"G": _G[m], "S": _S[m]}) if m.any() else pd.DataFrame({"G": [], "S": []})\n        return hv.Points(df, kdims=["G", "S"]).opts(color=color, size=5, alpha=0.9)\n\n    def _make_image_overlay_t4(ibounds, igeom, pbounds, pgeom, wl_idx, mode):\n        data = intensity_unstacked.isel(wavelength=wl_idx).values.copy()\n        if mode == "Image":\n            m = _imask(ibounds, igeom)\n        else:\n            m = _pmask(pbounds, pgeom)\n        if not m.any():\n            empty = np.full((H, W), np.nan)\n            return hv.Image((_xdim, _ydim, empty), kdims=["x", "y"], vdims=["intensity"]).opts(\n                alpha=0, colorbar=False,\n            )\n        sel_grid = np.zeros((H, W), dtype=bool)\n        sel_grid[_x[m], _y[m]] = True\n        masked = np.where(sel_grid, data, np.nan)\n        return hv.Image(\n            (_xdim, _ydim, masked.T),\n            kdims=["x", "y"], vdims=["intensity"],\n        ).opts(\n            cmap="viridis", alpha=1.0, colorbar=False,\n            clim=(float(np.nanmin(data)), float(np.nanmax(data))),\n        )\n\n    def _make_spectrum_t4(ibounds, igeom, pbounds, pgeom, mode):\n        if mode == "Image":\n            mask, color, src = _imask(ibounds, igeom), "steelblue", "image sel"\n        else:\n            mask, color, src = _pmask(pbounds, pgeom), "tomato", "phasor sel"\n        n = int(mask.sum())\n        if n == 0:\n            avg   = _intmat.mean(axis=0)\n            title = "Average Spectrum (all pixels)"\n            color = "gray"\n        else:\n            avg   = _intmat[mask].mean(axis=0)\n            title = f"Average Spectrum \u2014 {src}  ({n} px)"\n        return hv.Curve(\n            pd.DataFrame({"wavelength": _wl, "intensity": avg}),\n            kdims=["wavelength"], vdims=["intensity"],\n        ).opts(\n            frame_width=560, frame_height=_IMG_WW,\n            title=title, color=color,\n            xlabel="Wavelength (nm)", ylabel="Intensity",\n            line_width=2, show_grid=True, tools=["hover"],\n        )\n\n    # \u2500\u2500 Wire DynamicMaps \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    img_overlay_dmap_t4 = hv.DynamicMap(pn.bind(\n        _make_image_overlay_t4,\n        ibounds=img_bounds_t4.param.bounds,\n        igeom=img_lasso_t4.param.geometry,\n        pbounds=ph_bounds_t4.param.bounds,\n        pgeom=ph_lasso_t4.param.geometry,\n        wl_idx=wl_slider_t4,\n        mode=mode_toggle_t4,\n    ))\n    ph_overlay_dmap_t4 = hv.DynamicMap(pn.bind(\n        _make_phasor_overlay_t4,\n        ibounds=img_bounds_t4.param.bounds,\n        igeom=img_lasso_t4.param.geometry,\n        pbounds=ph_bounds_t4.param.bounds,\n        pgeom=ph_lasso_t4.param.geometry,\n        mode=mode_toggle_t4,\n    ))\n    spectrum_t4 = hv.DynamicMap(pn.bind(\n        _make_spectrum_t4,\n        ibounds=img_bounds_t4.param.bounds,\n        igeom=img_lasso_t4.param.geometry,\n        pbounds=ph_bounds_t4.param.bounds,\n        pgeom=ph_lasso_t4.param.geometry,\n        mode=mode_toggle_t4,\n    )).opts(framewise=True)\n\n    # \u2500\u2500 Composed panels \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    image_panel_t4 = (base_img_dmap_t4 * img_overlay_dmap_t4).opts(\n        hv.opts.Overlay(title="Image"),\n    )\n    phasor_panel_t4 = (ref_arc_t4 * phasor_bg_t4 * ph_overlay_dmap_t4).opts(\n        hv.opts.Overlay(\n            frame_width=_IMG_WW, frame_height=_IMG_WW,\n            xlabel="G", ylabel="S",\n            show_grid=True, padding=0.1,\n            title="Phasor",\n        ),\n    )\n\n    return pn.Column(\n        combined_warning,\n        info_md,\n        pn.Row(\n            wl_slider_t4,\n            pn.Spacer(width=30),\n            pn.Row(mode_toggle_t4, reset_btn_t4, sizing_mode="fixed"),\n            sizing_mode="fixed",\n        ),\n        pn.Row(image_panel_t4, phasor_panel_t4),\n        spectrum_t4,\n    )\n\n\n@pn.depends(\n    start_lambda_input,\n    step_lambda_input,\n    end_lambda_input,\n    harmonic_input,\n    t5_ref_a_wl,\n    t5_ref_a_std,\n    t5_ref_b_wl,\n    t5_ref_b_std,\n    t5_mix_ratio,\n    t5_n_samples,\n    t5_add_noise,\n    t5_snr,\n)\ndef tab5_view(\n    start, step, end, h,\n    ref_a_wl, ref_a_std, ref_b_wl, ref_b_std,\n    mix_ratio, n_samples, add_noise, snr_db,\n):\n    err = _validate_wavelengths(start, step, end)\n    if err:\n        return err\n\n    rng = np.random.default_rng()\n    wl = get_wavelengths(start, step, end)\n\n    # \u2500\u2500 Reference spectra \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    spec_a = make_gaussian(wl, ref_a_wl, ref_a_std)\n    spec_b = make_gaussian(wl, ref_b_wl, ref_b_std)\n\n    # \u2500\u2500 Mixed spectra P \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    mix_2d = np.outer(np.full(n_samples, mix_ratio), spec_a) + \\\n             np.outer(np.full(n_samples, 1.0 - mix_ratio), spec_b)\n\n    if add_noise:\n        snr_linear = 10 ** (snr_db / 10)\n        sig_power = np.mean(mix_2d ** 2, axis=1, keepdims=True)\n        noise_std = np.sqrt(sig_power / snr_linear)\n        noise = rng.standard_normal(mix_2d.shape) * noise_std\n        mix_2d = np.clip(mix_2d + noise, 0, None)\n\n    # \u2500\u2500 Phasor transform for refs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    all_spectra = np.vstack([spec_a[np.newaxis, :], spec_b[np.newaxis, :], mix_2d])\n    ds_all = make_spectra_dataset(wl, all_spectra, h)\n    ds_all = calculate_phasor_transform(ds_all)\n    ds_all = add_spectral_reference(ds_all)\n\n    G_a, S_a = ds_all["G"].values[0], ds_all["S"].values[0]\n    G_b, S_b = ds_all["G"].values[1], ds_all["S"].values[1]\n    G_p = ds_all["G"].values[2:]\n    S_p = ds_all["S"].values[2:]\n\n    # \u2500\u2500 Centroid of P cloud \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    G_pc, S_pc = G_p.mean(), S_p.mean()\n\n    # \u2500\u2500 Distance calculations \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    dist_AB = np.sqrt((G_b - G_a) ** 2 + (S_b - S_a) ** 2)\n    dist_PA = np.sqrt((G_pc - G_a) ** 2 + (S_pc - S_a) ** 2)\n    dist_PB = np.sqrt((G_pc - G_b) ** 2 + (S_pc - S_b) ** 2)\n    ratio_PA_AB = dist_PA / dist_AB if dist_AB > 1e-12 else float("nan")\n    ratio_PB_AB = dist_PB / dist_AB if dist_AB > 1e-12 else float("nan")\n\n    # Estimated mix ratio from phasor geometry:  fraction of B = PA/AB\n    estimated_a_fraction = 1.0 - ratio_PA_AB  # closer to A \u2192 more A\n\n    # \u2500\u2500 Spectral reference arc \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    df_ref = ds_all[["G_ref", "S_ref"]].to_dataframe().reset_index()\n    ref_arc = df_ref.hvplot.points(\n        x="G_ref", y="S_ref",\n        color="wavelength_ref", cmap="spectral_r",\n        size=28, colorbar=False, tools=["hover"],\n    )\n\n    # \u2500\u2500 Phasor plot: P cloud \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    df_p = pd.DataFrame({"G": G_p, "S": S_p})\n    p_cloud = hv.Points(df_p, kdims=["G", "S"]).opts(\n        color="gray", size=15, alpha=0.4, marker="circle",\n    )\n\n    # \u2500\u2500 Phasor plot: reference points A and B \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    pt_a = hv.Points(\n        pd.DataFrame({"G": [G_a], "S": [S_a], "label": ["A"]}),\n        kdims=["G", "S"], vdims=["label"],\n    ).opts(color="blue", size=30, marker="star_dot", alpha=0.8, tools=["hover"])\n    pt_b = hv.Points(\n        pd.DataFrame({"G": [G_b], "S": [S_b], "label": ["B"]}),\n        kdims=["G", "S"], vdims=["label"],\n    ).opts(color="red", size=30, marker="star_dot", alpha=0.8, tools=["hover"])\n    pt_pc = hv.Points(\n        pd.DataFrame({"G": [G_pc], "S": [S_pc], "label": ["P (centroid)"]}),\n        kdims=["G", "S"], vdims=["label"],\n    ).opts(color="green", size=30, marker="star_dot", alpha=0.8, tools=["hover"])\n    ref_points = pt_a * pt_b * pt_pc\n    ref_labels = hv.Labels(\n        pd.DataFrame({\n            "G": [G_a, G_b, G_pc],\n            "S": [S_a + 0.02, S_b + 0.02, S_pc + 0.02],\n            "text": ["A", "B", "P"],\n        }),\n        kdims=["G", "S"], vdims=["text"],\n    ).opts(text_font_size="12pt", text_color="black")\n\n    # \u2500\u2500 Line A\u2013B \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    ab_line = hv.Curve(\n        pd.DataFrame({"G": [G_a, G_b], "S": [S_a, S_b]}),\n        kdims=["G"], vdims=["S"],\n    ).opts(color="black", line_dash="dashed", line_width=1.5)\n\n    phasor_plot = (ref_arc * p_cloud * ref_points * ref_labels * ab_line).opts(\n        hv.opts.Points(\n            frame_width=500, frame_height=500, padding=0.1,\n            xlabel="G", ylabel="S", show_grid=True, show_legend=False,\n            title="Phasor Plot \u2014 2-way Deconvolution",\n        ),\n    )\n\n    # \u2500\u2500 Spectrum plot: A, B, average of P \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    avg_p = mix_2d.mean(axis=0)\n    spec_df = pd.DataFrame({\n        "wavelength": np.tile(wl, 3),\n        "intensity": np.concatenate([spec_a, spec_b, avg_p]),\n        "label": (\n            ["A (ref)"] * len(wl)\n            + ["B (ref)"] * len(wl)\n            + ["P (avg mix)"] * len(wl)\n        ),\n    })\n    spectrum_plot = spec_df.hvplot.line(\n        x="wavelength", y="intensity", by="label",\n        color=hv.Cycle(["blue", "red", "green"]),\n        line_width=3, frame_width=800, frame_height=500,\n        xlabel="Wavelength (nm)", ylabel="Intensity",\n        title="Spectra \u2014 References A, B and Mixed Average P",\n        legend="top_right",\n    )\n\n    # \u2500\u2500 Info & formula \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    formula_md = pn.pane.Markdown(\n        f"""**Reference spectra (area-normalized Gaussians):**\n\n$$A(\\\\lambda) = \\\\exp\\\\left(-\\\\frac{{(\\\\lambda - {ref_a_wl:.1f})^2}}{{2 \\\\cdot {ref_a_std:.1f}^2}}\\\\right)$$\n\n$$B(\\\\lambda) = \\\\exp\\\\left(-\\\\frac{{(\\\\lambda - {ref_b_wl:.1f})^2}}{{2 \\\\cdot {ref_b_std:.1f}^2}}\\\\right)$$\n\n**Mixed spectrum P generated as:**\n\n$$P(\\\\lambda) = {mix_ratio:.3f} \\\\cdot A(\\\\lambda) + {1.0 - mix_ratio:.3f} \\\\cdot B(\\\\lambda)$$"""\n    )\n    \n    info_md = pn.pane.Markdown(\n        f"### Phasor 2-Way Deconvolution\\n\\n"\n        f"| Quantity | Value |\\n"\n        f"|:---------|------:|\\n"\n        f"| A phasor | ({G_a:.4f}, {S_a:.4f}) |\\n"\n        f"| B phasor | ({G_b:.4f}, {S_b:.4f}) |\\n"\n        f"| P centroid | ({G_pc:.4f}, {S_pc:.4f}) |\\n"\n        f"| AB | {dist_AB:.4f} |\\n"\n        f"| PA | {dist_PA:.4f} |\\n"\n        f"| PB | {dist_PB:.4f} |\\n"\n        f"| PA / AB | {ratio_PA_AB:.4f} |\\n"\n        f"| PB / AB | {ratio_PB_AB:.4f} |\\n"\n        f"| **True A fraction** | **{mix_ratio:.4f}** |\\n"\n        f"| **Estimated A fraction** | **{estimated_a_fraction:.4f}** |\\n",\n        styles={"font-size": "14px"},\n    )\n\n    return pn.Column(\n        formula_md,\n        pn.Row(phasor_plot, spectrum_plot, sizing_mode="stretch_width"),\n        info_md,\n    )\n\n\n# \u2500\u2500 Tab 6: 3-way deconvolution \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ndef _triangle_area(x1, y1, x2, y2, x3, y3):\n    """Signed area of triangle via the shoelace formula (abs for unsigned)."""\n    return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\n\n\n@pn.depends(\n    start_lambda_input,\n    step_lambda_input,\n    end_lambda_input,\n    harmonic_input,\n    t6_ref_a_wl,\n    t6_ref_a_std,\n    t6_ref_b_wl,\n    t6_ref_b_std,\n    t6_ref_c_wl,\n    t6_ref_c_std,\n    t6_alpha,\n    t6_beta,\n    t6_gamma,\n    t6_n_samples,\n    t6_add_noise,\n    t6_snr,\n)\ndef tab6_view(\n    start, step, end, h,\n    ref_a_wl, ref_a_std, ref_b_wl, ref_b_std, ref_c_wl, ref_c_std,\n    alpha, beta, gamma, n_samples, add_noise, snr_db,\n):\n    err = _validate_wavelengths(start, step, end)\n    if err:\n        return err\n\n    rng = np.random.default_rng()\n    wl = get_wavelengths(start, step, end)\n\n    # \u2500\u2500 Reference spectra \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    spec_a = make_gaussian(wl, ref_a_wl, ref_a_std)\n    spec_b = make_gaussian(wl, ref_b_wl, ref_b_std)\n    spec_c = make_gaussian(wl, ref_c_wl, ref_c_std)\n\n    # \u2500\u2500 Mixed spectra P = \u03b1\xb7A + \u03b2\xb7B + \u03b3\xb7C \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    mix_2d = (\n        np.outer(np.full(n_samples, alpha), spec_a)\n        + np.outer(np.full(n_samples, beta), spec_b)\n        + np.outer(np.full(n_samples, gamma), spec_c)\n    )\n\n    if add_noise:\n        snr_linear = 10 ** (snr_db / 10)\n        sig_power = np.mean(mix_2d ** 2, axis=1, keepdims=True)\n        noise_std = np.sqrt(sig_power / snr_linear)\n        noise = rng.standard_normal(mix_2d.shape) * noise_std\n        mix_2d = np.clip(mix_2d + noise, 0, None)\n\n    # \u2500\u2500 Phasor transform \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    all_spectra = np.vstack([\n        spec_a[np.newaxis, :],\n        spec_b[np.newaxis, :],\n        spec_c[np.newaxis, :],\n        mix_2d,\n    ])\n    ds_all = make_spectra_dataset(wl, all_spectra, h)\n    ds_all = calculate_phasor_transform(ds_all)\n    ds_all = add_spectral_reference(ds_all)\n\n    G_a, S_a = ds_all["G"].values[0], ds_all["S"].values[0]\n    G_b, S_b = ds_all["G"].values[1], ds_all["S"].values[1]\n    G_c, S_c = ds_all["G"].values[2], ds_all["S"].values[2]\n    G_p = ds_all["G"].values[3:]\n    S_p = ds_all["S"].values[3:]\n\n    # \u2500\u2500 Centroid of P cloud \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    G_pc, S_pc = G_p.mean(), S_p.mean()\n\n    # \u2500\u2500 Triangle-area deconvolution \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    area_ABC = _triangle_area(G_a, S_a, G_b, S_b, G_c, S_c)\n    area_PBC = _triangle_area(G_pc, S_pc, G_b, S_b, G_c, S_c)  # opposite A\n    area_APC = _triangle_area(G_a, S_a, G_pc, S_pc, G_c, S_c)  # opposite B\n    area_ABP = _triangle_area(G_a, S_a, G_b, S_b, G_pc, S_pc)  # opposite C\n\n    if area_ABC > 1e-12:\n        est_alpha = area_PBC / area_ABC\n        est_beta  = area_APC / area_ABC\n        est_gamma = area_ABP / area_ABC\n    else:\n        est_alpha = est_beta = est_gamma = float("nan")\n\n    # \u2500\u2500 Spectral reference arc \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    df_ref = ds_all[["G_ref", "S_ref"]].to_dataframe().reset_index()\n    ref_arc = df_ref.hvplot.points(\n        x="G_ref", y="S_ref",\n        color="wavelength_ref", cmap="spectral_r",\n        size=28, colorbar=False, tools=["hover"],\n    )\n\n    # \u2500\u2500 P cloud \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    df_p = pd.DataFrame({"G": G_p, "S": S_p})\n    p_cloud = hv.Points(df_p, kdims=["G", "S"]).opts(\n        color="gray", size=15, alpha=0.4, marker="circle",\n    )\n\n    # \u2500\u2500 Reference points A, B, C & centroid \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    pt_a = hv.Points(\n        pd.DataFrame({"G": [G_a], "S": [S_a], "label": ["A"]}),\n        kdims=["G", "S"], vdims=["label"],\n    ).opts(color="blue", size=30, marker="star_dot", alpha=0.8, tools=["hover"])\n    pt_b = hv.Points(\n        pd.DataFrame({"G": [G_b], "S": [S_b], "label": ["B"]}),\n        kdims=["G", "S"], vdims=["label"],\n    ).opts(color="red", size=30, marker="star_dot", alpha=0.8, tools=["hover"])\n    pt_c = hv.Points(\n        pd.DataFrame({"G": [G_c], "S": [S_c], "label": ["C"]}),\n        kdims=["G", "S"], vdims=["label"],\n    ).opts(color="orange", size=30, marker="star_dot", alpha=0.8, tools=["hover"])\n    pt_pc = hv.Points(\n        pd.DataFrame({"G": [G_pc], "S": [S_pc], "label": ["P (centroid)"]}),\n        kdims=["G", "S"], vdims=["label"],\n    ).opts(color="green", size=30, marker="star_dot", alpha=0.8, tools=["hover"])\n    ref_points = pt_a * pt_b * pt_c * pt_pc\n    ref_labels = hv.Labels(\n        pd.DataFrame({\n            "G": [G_a, G_b, G_c, G_pc],\n            "S": [S_a + 0.02, S_b + 0.02, S_c + 0.02, S_pc + 0.02],\n            "text": ["A", "B", "C", "P"],\n        }),\n        kdims=["G", "S"], vdims=["text"],\n    ).opts(text_font_size="12pt", text_color="black")\n\n    # \u2500\u2500 Triangle A\u2013B\u2013C \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    tri = hv.Curve(\n        pd.DataFrame({"G": [G_a, G_b, G_c, G_a], "S": [S_a, S_b, S_c, S_a]}),\n        kdims=["G"], vdims=["S"],\n    ).opts(color="black", line_dash="dashed", line_width=1.5)\n\n    phasor_plot = (ref_arc * p_cloud * ref_points * ref_labels * tri).opts(\n        hv.opts.Points(\n            frame_width=500, frame_height=500, padding=0.1,\n            xlabel="G", ylabel="S", show_grid=True, show_legend=False,\n            title="Phasor Plot \u2014 3-way Deconvolution",\n        ),\n    )\n\n    # \u2500\u2500 Spectrum plot: A, B, C, average P \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    avg_p = mix_2d.mean(axis=0)\n    spec_df = pd.DataFrame({\n        "wavelength": np.tile(wl, 4),\n        "intensity": np.concatenate([spec_a, spec_b, spec_c, avg_p]),\n        "label": (\n            ["A (ref)"] * len(wl)\n            + ["B (ref)"] * len(wl)\n            + ["C (ref)"] * len(wl)\n            + ["P (avg mix)"] * len(wl)\n        ),\n    })\n    spectrum_plot = spec_df.hvplot.line(\n        x="wavelength", y="intensity", by="label",\n        color=hv.Cycle(["blue", "red", "orange", "green"]),\n        line_width=3, frame_width=800, frame_height=500,\n        xlabel="Wavelength (nm)", ylabel="Intensity",\n        title="Spectra \u2014 References A, B, C and Mixed Average P",\n        legend="top_right",\n    )\n\n    # \u2500\u2500 Info & formula \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    formula_md = pn.pane.Markdown(\n        f"""**Reference spectra (area-normalized Gaussians):**\n\n$$A(\\\\lambda) = \\\\exp\\\\left(-\\\\frac{{(\\\\lambda - {ref_a_wl:.1f})^2}}{{2 \\\\cdot {ref_a_std:.1f}^2}}\\\\right)$$\n\n$$B(\\\\lambda) = \\\\exp\\\\left(-\\\\frac{{(\\\\lambda - {ref_b_wl:.1f})^2}}{{2 \\\\cdot {ref_b_std:.1f}^2}}\\\\right)$$\n\n$$C(\\\\lambda) = \\\\exp\\\\left(-\\\\frac{{(\\\\lambda - {ref_c_wl:.1f})^2}}{{2 \\\\cdot {ref_c_std:.1f}^2}}\\\\right)$$\n\n**Mixed spectrum P generated as:**\n\n$$P(\\\\lambda) = {alpha:.3f} \\\\cdot A(\\\\lambda) + {beta:.3f} \\\\cdot B(\\\\lambda) + {gamma:.3f} \\\\cdot C(\\\\lambda)$$\n\n**Triangle-area deconvolution:**\n\n$$\\\\hat{{\\\\alpha}} = \\\\frac{{\\\\Delta_{{PBC}}}}{{\\\\Delta_{{ABC}}}}, \\\\quad\n\\\\hat{{\\\\beta}}  = \\\\frac{{\\\\Delta_{{APC}}}}{{\\\\Delta_{{ABC}}}}, \\\\quad\n\\\\hat{{\\\\gamma}} = \\\\frac{{\\\\Delta_{{ABP}}}}{{\\\\Delta_{{ABC}}}}$$"""\n    )\n\n    info_md = pn.pane.Markdown(\n        f"### Phasor 3-Way Deconvolution\\n\\n"\n        f"| Quantity | Value |\\n"\n        f"|:---------|------:|\\n"\n        f"| A phasor | ({G_a:.4f}, {S_a:.4f}) |\\n"\n        f"| B phasor | ({G_b:.4f}, {S_b:.4f}) |\\n"\n        f"| C phasor | ({G_c:.4f}, {S_c:.4f}) |\\n"\n        f"| P centroid | ({G_pc:.4f}, {S_pc:.4f}) |\\n"\n        f"| \u0394ABC | {area_ABC:.6f} |\\n"\n        f"| \u0394PBC | {area_PBC:.6f} |\\n"\n        f"| \u0394APC | {area_APC:.6f} |\\n"\n        f"| \u0394ABP | {area_ABP:.6f} |\\n"\n        f"| **True \u03b1 (A)** | **{alpha:.4f}** |\\n"\n        f"| **Estimated \u03b1** | **{est_alpha:.4f}** |\\n"\n        f"| **True \u03b2 (B)** | **{beta:.4f}** |\\n"\n        f"| **Estimated \u03b2** | **{est_beta:.4f}** |\\n"\n        f"| **True \u03b3 (C)** | **{gamma:.4f}** |\\n"\n        f"| **Estimated \u03b3** | **{est_gamma:.4f}** |\\n",\n        styles={"font-size": "14px"},\n    )\n\n    return pn.Column(\n        formula_md,\n        pn.Row(phasor_plot, spectrum_plot, sizing_mode="stretch_width"),\n        info_md,\n    )\n\n\n# \u2500\u2500 Sidebar layout \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nglobal_card = pn.Card(\n    start_lambda_input,\n    step_lambda_input,\n    end_lambda_input,\n    harmonic_input,\n    show_individual,\n    title="Global Parameters",\n    collapsed=False,\n)\n\ntab1_card = pn.Card(\n    t1_mean,\n    t1_std,\n    title="1) Single Gaussian",\n    collapsed=False,\n)\n\ntab2_card = pn.Card(\n    t2_n_samples,\n    t2_mean_base,\n    t2_mean_spread,\n    t2_std_base,\n    t2_std_spread,\n    t2_add_noise,\n    t2_snr,\n    title="2) Multi Gaussian + Noise",\n    collapsed=True,\n)\n\ntab3_card = pn.Card(\n    t3_file_input,\n    title="3) Fluorescence Spectra (CSV)",\n    collapsed=True,\n)\n\ntab4_card = pn.Card(\n    t4_file_input,\n    pn.pane.Markdown(\n        "**Start \u03bb** and **End \u03bb** from Global Parameters define the wavelength range.  \\n"\n        "**Step \u03bb** is ignored \u2014 it is auto-computed as linspace over the TIFF frame count."\n    ),\n    title="4) TIFF Image Stack",\n    collapsed=True,\n)\n\ntab5_card = pn.Card(\n    t5_ref_a_wl,\n    t5_ref_a_std,\n    t5_ref_b_wl,\n    t5_ref_b_std,\n    t5_mix_ratio,\n    t5_n_samples,\n    t5_add_noise,\n    t5_snr,\n    title="5) 2-Way Deconvolution",\n    collapsed=True,\n)\n\ntab6_card = pn.Card(\n    t6_ref_a_wl,\n    t6_ref_a_std,\n    t6_ref_b_wl,\n    t6_ref_b_std,\n    t6_ref_c_wl,\n    t6_ref_c_std,\n    t6_alpha,\n    t6_beta,\n    t6_gamma,\n    t6_n_samples,\n    t6_add_noise,\n    t6_snr,\n    title="6) 3-Way Deconvolution",\n    collapsed=True,\n)\n\nsidebar = pn.Column(\n    global_card,\n    tab1_card,\n    tab2_card,\n    tab3_card,\n    tab4_card,\n    tab5_card,\n    tab6_card,\n    margin=(10, 10),\n)\n\n# \u2500\u2500 Main layout \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nheader = pn.Column(\n    pn.pane.Markdown("# Spectral Phasors Analysis"),\n    pn.pane.Markdown(\n        "Select a tab to explore different modalities. "\n        "Global wavelength range and harmonic apply to all tabs."\n    ),\n)\n\nmain_tabs = pn.Tabs(\n    ("1) Single Gaussian", tab1_view),\n    ("2) Multi Gaussian + Noise", tab2_view),\n    ("3) Fluorescence Spectra (CSV)", tab3_view),\n    ("4) TIFF Image Stack", tab4_view),\n    ("5) 2-Way Deconvolution", tab5_view),\n    ("6) 3-Way Deconvolution", tab6_view),\n    # dynamic=True,\n)\n\nmain_area = pn.Column(header, main_tabs, margin=(10, 20))\n\n# \u2500\u2500 Sync tab \u2194 sidebar card collapse \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n_tab_cards = {0: tab1_card, 1: tab2_card, 2: tab3_card, 3: tab4_card, 4: tab5_card, 5: tab6_card}\n\n\ndef _sync_cards(event):\n    """Collapse every tab-specific card except the one for the active tab.\n    Also disable Step \u03bb when the TIFF tab (index 3) is active, since wavelengths\n    are derived automatically from linspace(start, end, n_frames).\n    """\n    for idx, card in _tab_cards.items():\n        card.collapsed = idx != event.new\n    step_lambda_input.disabled = (event.new == 3)\n    show_individual.disabled = (event.new in (4, 5))\n\n\nmain_tabs.param.watch(_sync_cards, "active")\n\n# \u2500\u2500 Auto-enable show_individual on CSV upload \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n\ndef _on_csv_upload(event):\n    if event.new is not None:\n        show_individual.value = True\n        main_tabs.active = 2\n        \n        # pn.state.location.reload = False\n        # pn.state.location.reload = True\n\n\nt3_file_input.param.watch(_on_csv_upload, "value")\n\n\ndef _on_tiff_upload(event):\n    if event.new is not None:\n        main_tabs.active = 3\n        # pn.state.location.reload = False\n        # pn.state.location.reload = True\n\n\nt4_file_input.param.watch(_on_tiff_upload, "value")\n\ntemplate = pn.template.BootstrapTemplate(\n    site="Spectral Analysis",\n    title="Phasors App",\n    sidebar=[sidebar],\n    main=[main_area],\n)\n\ntemplate.servable()\n\nif __name__ == "__main__" and "pyodide" not in sys.modules:\n    pn.serve(template, show=True, port=5900)\n\n\nawait write_doc()`)
    self.postMessage({
      type: 'render',
      docs_json: docs_json,
      render_items: render_items,
      root_ids: root_ids
    })
  } catch(e) {
    const traceback = `${e}`
    const tblines = traceback.split('\n')
    self.postMessage({
      type: 'status',
      msg: tblines[tblines.length-2]
    });
    throw e
  }
}

self.onmessage = async (event) => {
  const msg = event.data
  if (msg.type === 'rendered') {
    self.pyodide.runPythonAsync(`
    from panel.io.state import state
    from panel.io.pyodide import _link_docs_worker

    _link_docs_worker(state.curdoc, sendPatch, setter='js')
    `)
  } else if (msg.type === 'patch') {
    self.pyodide.globals.set('patch', msg.patch)
    self.pyodide.runPythonAsync(`
    from panel.io.pyodide import _convert_json_patch
    state.curdoc.apply_json_patch(_convert_json_patch(patch), setter='js')
    `)
    self.postMessage({type: 'idle'})
  } else if (msg.type === 'location') {
    self.pyodide.globals.set('location', msg.location)
    self.pyodide.runPythonAsync(`
    import json
    from panel.io.state import state
    from panel.util import edit_readonly
    if state.location:
        loc_data = json.loads(location)
        with edit_readonly(state.location):
            state.location.param.update({
                k: v for k, v in loc_data.items() if k in state.location.param
            })
    `)
  }
}

startApplication()